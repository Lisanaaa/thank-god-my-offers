### 说一下 volatile 关键字和指令重排序的关系

**为什么要重排序**

一个指令的执行被分成：取指、译码、访存、执行、写回、等若干个阶段。然后，多条指令可以同时存在于流水线中，同时被执行。重排序的目的是为了性能。

**as-if-serial**

as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。

编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。分为下面三种情况：

名称	| 示例 | 说明
写后读|	a = 1; b = a;	|写一个变量后再读这个位置
写后写|	a = 1; a = 2;	|写一个变量后再写这个变量
读后写|	a = b; b = 1;	|读一个变量后再写这个变量

上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。所以有数据依赖性的语句不能进行重排序

**volatile 关键字**

volatile 有两层含义：
1. 保证了不同线程对这个变量进行操作时的**可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

Example:
```java
// 线程1
boolean stop = false;
while(!stop){
    doSomething();
}
// 线程2
stop = true;
```

先看这段代码会完全运行正确么？即一定会将线程中断么？
答案是：不一定！

线程1在运行的时候，会将 stop 变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了 stop 变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对 stop 变量的更改，因此还会一直循环下去。

如果加上 volatile 则不一样：

- 使用 volatile 关键字会强制将修改的值立即写入主存。
- 使用 volatile 关键字的话，当线程2已经对变量在主存进行修改时，会导致线程1的工作内存中缓存变量 stop 的缓存行无效。（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）
- 由于线程1的工作内存中缓存变量 stop 的缓存行无效，所以线程1再次读取变量 stop 的值时会去主存读取。

2. 禁止进行指令重排序。

当程序执行到 volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。
Example:
```java
//x、y为非volatile变量
//flag为volatile变量

x = 2;         //语句1
y = 0;         //语句2
flag = true;   //语句3
x = 4;         //语句4
y = -1;        //语句5
```
由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。

并且 volatile 关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。

**volatile 能保证原子性吗**

不能，为什么呢，举个例子，循环自增操作，关键在于自增操作不是原子的。自增操作分为3步：

- 读取变量的原始值
- 进行加1操作，这时候还是在自己工作内存中
- 写入工作内存

i++实际为load、Increment、store三个操作。

以volatile int i = 10；i++；为例分析：某一时刻线程1将i的值load取出来，放置到cpu缓存中，然后再将此值放置到寄存器A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改i，因此其他线程并不会获取到这个自增1的值）。如果在此时线程2也执行同样的操作，获取值i==10,自增1变为11，然后马上刷入主内存。此时由于线程2修改了i的值，实时的线程1中的i==10的值缓存失效，重新从主内存中读取，变为11。接下来线程1恢复。将自增过后的A寄存器值11赋值给cpu缓存i。这样就出现了线程安全问题。这里的线程安全问题指的是线程1的结果不如它的预期了。

加深一下对原子性的理解，请分析以下哪些操作是原子性操作：
```java
x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
```
乍一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。

- 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
- 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的- 值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
- 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

所以上面4个语句只有语句1的操作具备原子性。

### 2. 用过哪些线程池,说一下常见的四种线程池和区别

为了彻底了解线程池的时候，我们需要弄清楚线程池创建的几个参数
* corepollsize : 核心池的大小，默认情况下，在创建线程池后，每当有新的任务来的时候，如果此时线程池中的线程数小于核心线程数，就会去创建一个线程执行（就算有空线程也不复用），当创建的线程数达到核心线程数之后，再有任务进来就会放入任务缓存队列中
* Maximumpoolsize : 线程池中最多可以创建的线程数
* keeplivetime : 线程空闲状态时，最多保持多久的时间会终止。默认情况下，当线程池中的线程数大于corepollsize 时，才会起作用 ，直到线程数不大于 corepollsize 。
* workQuque: 阻塞队列，用来存放等待的任务
*rejectedExecutionHandler ：任务拒绝处理器（这个注意一下），有四种（1）abortpolicy丢弃任务，抛出异常（2）discardpolicy拒绝执行，不抛异常（3）discardoldestpolicy 丢弃任务缓存队列中最老的任务（4）CallerRunsPolicy 线程池不执行这个任务，主线程自己执行。

#### 1、newFixedThreadPool  定长线程池
一个有指定的线程数的线程池，有核心的线程，里面有固定的线程数量，响应的速度快。正规的并发线程，多用于服务器。固定的线程数由系统资源设置。核心线程是没有超时机制的，队列大小没有限制，除非线程池关闭了核心线程才会被回收。
#### 2、newCachedThreadPool 可缓冲线程池
只有非核心线程，最大线程数很大，每新来一个任务，当没有空余线程的时候就会重新创建一个线程，这边有一个超时机制，当空闲的线程超过60s内没有用到的话，就会被回收，它可以一定程序减少频繁创建/销毁线程,减少系统开销，适用于执行时间短并且数量多的任务场景。

#### 3、ScheduledThreadPool  周期线程池
创建一个定长线程池，支持定时及周期性任务执行，通过过schedule方法可以设置任务的周期执行

#### 4、newSingleThreadExecutor 单任务线程池
创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行，每次任务到来后都会进入阻塞队列，然后按指定顺序执行。

## References
1. [Java中的重排序和 volatile 关键字](https://www.jianshu.com/p/b4d4506d3585)
